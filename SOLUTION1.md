We decided to approach Deliverable 1 by splitting the extensions to be added to the parser in half, with each of us individually implementing our half. Once we had finished adding our implementations to `TIP.g4`, we then began testing each other's implemented features in `SIPParserTest.cpp`. We structured our approach this way so that as we tested the other's additions to the parser, we would be able to catch any incorrect assumptions the other partner had made.

As we worked on this deliverable, we ran into a few obstacles that required us to come together and work on them together. One example is in adding the 2 supported forms of for-loops in the SIP language. At first, we had only added 1 for loop statement that supported both the iterator-style and range-style. However, after being present for Professor Dwyer's discussion of the consequences of parsing for-loops as a single node or 2 nodes for each style, we made the group decision to change our implementation to instead have 2 separate statement types for each style. Another tricky aspect in our implementation was balancing the operator precedence of all the extensions we added for SIP. One such example is that we had initially implemented binary operators `and` and `or`, to have equal precedence. However, as we tested to make sure our extensions followed the established C Operator Precedence, we had realized that Logical `and` should actually have higher precedence that Logical `or`. We gained a better understanding for the virtues of testing with the addition of the arithmetic negation operator `-`. We initially struggled with how to support both an arithmetic negation operator and negative numbers in the SIP language. However, when testing for precedence, we realized that having the expression definition `SUB expr` before `SUB NUMBER` meant that every token preceded with a `-` would be read as a negative expression rather than a negative number since `NUMBER` is also defined in the expression sub-grammar, meaning that `SUB NUMBER` had to come first for the SIP compiler to function as desired.

To expand on our approach to testing in Deliverable 1, we focused on making sure every implemented extension was covered by a test in `SIPParserTest.cpp`. This generally resulted in every addition having a positive case where we validated that a normal use of the implementation could be parsed correctly. Furthermore, we expanded upon this to generate a negative case where we validated that an invalid use of the implementation would be rejected. One such example is with the Array range constructor (`[E1 of E2]`). We tested it's positive/equivalence case with valid syntax `x = [y of 12];`, and its negative case with `x = [y-- of 12];` where the use of the statement `y--` caused the program to be rejected. However, a negative case was not always a meaningful test case to add. For example, with the modulus operator since a valid parsing would be any 2 expressions interjected with a `%` creating a negative case would mimic the same logic as the negative case for the array range constructor (substituting an expression with a statement). Furthermore, we were careful to test operator precedence with any operator that was not already implemented in TIP. Our strategy to confirming our implementations followed C Operator Precedence was to employ a distributive logic. For example, once we had tested modulus's operator precedence to be at the correct level, we tested the precedence operator's implemented later (like arithmetic negation) against modulus. By doing so, we can still validate correct operator precedence while avoiding writing redundant tests.
